---
title: "R for data science"
output:
  pdf_document: default
  html_document: default
  github_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(error = TRUE)
```


# Preparation

```{r}
# install.packages("tidyverse")
# install.packages(c("nycflights13", "gapminder", "Lahman"))
```


# Part 1. Explore  

```{r}
library(tidyverse)
```

```{r}
tidyverse_update()
```


## 1. Data Visualization with ggplot2

```{r}
library(tidyverse)
ggplot2::mpg
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

```{r}
#ggplot(data = <DATA>) + 
#  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = 'blue')
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap( ~ class, nrow = 2)
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ,y = hwy)) + 
  facet_grid(drv ~ cyl)
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(. ~ cyl)
```


```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```


```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv, color = drv))
```

```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
```

```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, color = drv), 
              show.legend = FALSE)
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(
    data = filter(mpg, class == 'subcompact'),
    se = FALSE
  )
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))
```

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut, y = ..count..))
```

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut, y = ..prop..))
```

```{r}
demo <- tribble(
  ~a, ~b,
  "bar_1", 20,
  "bar_2", 30,
  "bar_3", 40
)

ggplot(data = demo) + 
  geom_bar(
    mapping = aes(x = a, y = b), stat = 'identity'
  )
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, y = ..prop.., group = 1)
  )
```

```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )
```

```{r}
?stat_bin
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, color = cut))
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

```{r}
ggplot(data = diamonds, 
       mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
```

```{r}
ggplot(data = diamonds, 
       mapping = aes(x = cut, color = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), 
           position = "fill")
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = clarity),
    position = 'dodge'
  )
```

```{r}
ggplot(data = mpg) + 
  geom_point(
    mapping = aes(x = displ, y = hwy),
    position = 'jitter'
  )
```

```{r}
ggplot(data = mpg) + 
  geom_jitter(mapping = aes(x = displ, y = hwy))
```

```{r}
ggplot(data = mpg,
       mapping = aes(x = class, y = hwy)) + 
  geom_boxplot()
```

```{r}
ggplot(data = mpg, 
       mapping = aes(x = class, y = hwy)) + 
  geom_boxplot() + 
  coord_flip()
```

```{r}
#install.packages('maps')
library(maps)
nz <- map_data("nz")
ggplot(nz, aes(long, lat, group = group)) + 
  geom_polygon(fill = "white", color = "black")
```

```{r}
ggplot(nz, aes(long, lat, group = group)) + 
  geom_polygon(fill = "white", color = "black") + 
  coord_quickmap()
```

```{r}
bar <- ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut),
           show.legend = FALSE,
           width = 1) + 
  theme(aspect.ratio = 1) + 
  labs(x = NULL, y = NULL)

bar + coord_flip()
bar + coord_polar()
```

```{r}
#ggplot(data = <DATA>) + 
# <GEOM_FUNCTION>(
#   mapping = aes(<MAPPINGS>),
#   stat = <STAT>,
#   position = <POSITION>
# + 
# <COORDINATE_FUNCTION> + 
# <FACET_FUNCTION>
```


## 2. Workflow: Basic 

```{r}
seq(1,10)
```

```{r}
(y <- seq(1,10,length.out = 5))
```

## 3. Data transformation with dplyr 

```{r}
# install.packages('nycflights13')
library(nycflights13)
library(tidyverse)
```

```{r}
nycflights13::flights
```

```{r}
View(flights)
```

```{r}
class(flights)
```

```{r}
filter(flights, month == 1, day == 1)
```

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

```{r}
(dec25 <- filter(flights, month == 12, day == 25)) 
```

```{r}
#filter(flights, month = 1)
```

```{r}
sqrt(2)^2 == 2
```

```{r}
1/49*49 == 1
```

```{r}
near(sqrt(2)^2,2)
```

```{r}
near(1/49*49,1)
```

```{r}
filter(flights, month == 11 | month == 12)
```

```{r}
nov_dec <- filter(flights, month %in% c(11,12))
```

```{r}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
```

```{r}
filter(flights, arr_delay <= 120, dep_delay <= 120)
```

```{r}
NA > 5
```

```{r}
10 == NA
```

```{r}
NA + 10
```

```{r}
NA == NA
```

```{r}
x = NA
is.na(x)
```

```{r}
# filter only includes rows where the condition is TRUE, it excludes both FALSE and NA values. 
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
```

```{r}
filter(df, is.na(x) | x > 1)
```

```{r}
arrange(flights, year, month, day)
```

```{r}
arrange(flights, desc(arr_delay))
```

```{r}
# missing values are always sorted at the end 
df <- tibble(x = c(5,2,NA))
arrange(df, x)
```

```{r}
arrange(df, desc(x))
```

```{r}
select(flights, year, month, day)
```

```{r}
select(flights, year:day)
```

```{r}
select(flights, -(year:day))
```

```{r}
rename(flights, tail_num  = tailnum)
```

```{r}
select(flights, time_hour, air_time, everything())
```

```{r}
flights_sml <- select(flights, 
                      year:day,
                      ends_with("delay"),
                      distance, 
                      air_time)

mutate(flights_sml,
       gain = arr_delay - dep_delay,
       speed = distance / air_time * 60)
```

```{r}
mutate(flights_sml,
       gain = arr_delay - dep_delay,
       hours = air_time / 60,
       gain_per_hour = gain / hours)
```

```{r}
transmute(flights,
          gain = arr_delay - dep_delay,
          hours = air_time / 60,
          gain_per_hour = gain / hours)
```

```{r}
transmute(flights,
          dep_time, 
          hour = dep_time %/% 100,
          minute = dep_time %% 100)
```

```{r}
transmute(flights,
          dep_time,
          hour = dep_time %/% 100,
          minute = dep_time %% 100)
```

```{r}
x <- 1:10
lag(x)
lead(x)
```

```{r}
# install.packages("RcppRoll")
library(RcppRoll)
```

```{r}
cumsum(x)
cummean(x)
```

```{r}
v <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
min_rank(desc(y))
```

```{r}
row_number(y)
dense_rank(y)
percent_rank(y)
cume_dist(y)
ntile(y,100)
```

```{r}
summarize(flights, delay = mean(dep_delay, na.rm = TRUE))
```

```{r}
by_day <- group_by(flights, year, month, day)
summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

```{r}
by_dest <- group_by(flights, dest)
delay <- summarize(by_dest,
                   count = n(),
                   dist = mean(distance, na.rm = TRUE),
                   delay = mean(arr_delay, na.rm = TRUE))
delay <- filter(delay, count > 20, dest != 'HNL')
```

```{r}
ggplot(data = delay, mapping = aes(x = dist, y = delay)) + 
  geom_point(aes(size = count), alpha = 1/3) + 
  geom_smooth(se = FALSE)
```

```{r}
delays <- flights %>%
  group_by(dest) %>%
  summarize(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>%
  filter(count > 20, dest != 'HNL')
```

```{r}
# install.packages('ggvis')
library(ggvis)
```

```{r}
?ggvis
```

```{r}
flights %>% 
  group_by(year, month, day) %>%
  summarize(mean = mean(dep_delay))
```

```{r}
flights %>% 
        group_by(year, month, day) %>%
        summarize(mean = mean(dep_delay, na.rm = TRUE))
```

```{r}
not_cancelled <- flights %>%
  filter(!is.na(dep_delay), !is.na(arr_delay))
```

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(mean = mean(dep_delay))
```

```{r}
delays <- not_cancelled %>%
  group_by(tailnum) %>%
  summarize(
    delay = mean(arr_delay)
  )

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)
```

```{r}
delays <- not_cancelled %>%
  group_by(tailnum) %>% 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)
```

```{r}
delays %>%
  filter(n > 25) %>%
  ggplot(mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)
```

```{r}
# install.packages('Lahman')
library(Lahman)
batting <- as_tibble(Lahman::Batting)

batters <- batting %>%
  group_by(playerID) %>%
  summarize(
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    ab = sum(AB, na.rm = TRUE)
  )

batters %>%
  filter(ab > 100) %>%
  ggplot(mapping = aes(x = ab, y = ba)) +
  geom_point() + 
  geom_smooth(se = FALSE)
```

```{r}
batters %>% 
  arrange(desc(ba))
```

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay > 0])
  )
```

```{r}
not_cancelled %>%
  group_by(dest) %>%
  summarize(
    distance_sd = sd(distance)
  ) %>%
  arrange(desc(distance_sd))
```

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(
    first = min(dep_time),
    last = max(dep_time)
  )
```

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(
    first_dep = first(dep_time),
    last_dep = last(dep_time)
  )
```

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  mutate(r = min_rank(desc(dep_time))) %>%
  filter(r %in% range(r))
```

```{r}
not_cancelled %>%
  group_by(dest) %>%
  summarize(carriers = n_distinct(carrier)) %>%
  arrange(desc(carriers))
```

```{r}
not_cancelled %>%
  count(dest)
```

```{r}
not_cancelled %>%
  count(tailnum, wt = distance)
```

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(n_ealy = sum(dep_time < 500))
```

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(hour_perc = mean(arr_delay > 60))
```

```{r}
daily <- group_by(flights, year, month, day)
(per_day <- summarize(daily, flights = n()))
```

```{r}
(per_month <- summarize(per_day, flights = sum(flights)))
```

```{r}
(per_year <- summarize(per_month, flights = sum(flights)))
```

```{r}
daily %>%
  ungroup() %>%
  summarize(flights = n())
```

```{r}
flights_sml %>%
  group_by(year, month, day) %>%
  filter(rank(desc(arr_delay)) < 10)
```

```{r}
popular_dests <- flights %>%
  group_by(dest) %>%
  filter(n() > 365)
popular_dests
```

```{r}
popular_dests %>%
  filter(arr_delay > 0) %>%
  mutate(prop_delay = arr_delay / sum(arr_delay)) %>%
  select(year:day, dest, arr_delay, prop_delay)
```

```{r}
vignette('window-functions')
```


## 4. Workflow: Scripts 

## 5. Exploratory data analysts

```{r}
library(tidyverse)
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..count..))
```

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut), stat = 'count')
```


```{r}
diamonds %>% 
  count(cut)
```

```{r}
ggplot(data = diamonds) + 
  geom_histogram(mapping = aes(x = carat), 
                 binwidth = 0.5)
```

```{r}
diamonds %>%
  count(cut_width(carat, 0.5))
```

```{r}
smaller <- diamonds %>%
  filter(carat < 3)

ggplot(data = smaller, 
       mapping = aes(x = carat)) + 
  geom_histogram(binwidth = 0.1)
```

```{r}
ggplot(data = smaller,
       mapping = aes(x = carat, color = cut)) + 
  geom_freqpoly(binwidth = 0.1)
```

```{r}
ggplot(data = smaller, 
       mapping = aes(x = carat)) + 
  geom_histogram(binwidth = 0.01)
```

```{r}
ggplot(data = faithful,
       mapping = aes(x = eruptions)) + 
  geom_histogram(binwidth = 0.25)
```

```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)
```

```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) + 
  coord_cartesian(ylim = c(0,50))
```

```{r}
unusual <- diamonds %>%
  filter(y < 3 | y > 20) %>%
  arrange(y)
unusual
```

```{r}
diamonds2 <- diamonds %>%
  filter(between(y,3,20))
```

```{r}
diamonds2 <- diamonds %>%
  mutate(y = ifelse(y < 3 | y > 20, NA, y))
```

```{r}
ggplot(data = diamonds2, 
       mapping = aes(x = x, y =y)) + 
  geom_point()
```

```{r}
ggplot(data = diamonds2, 
       mapping = aes(x = x, y = y)) + 
  geom_point(na.rm = TRUE)
```

```{r}
nycflights13::flights %>%
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + sched_min / 60
  ) %>%
ggplot(mapping = aes(sched_dep_time)) + 
  geom_freqpoly(
    mapping = aes(color = cancelled),
    binwidth = 1/4
  )
```

```{r}
ggplot(data = diamonds, mapping = aes(x = price)) + 
  geom_freqpoly(mapping = aes(color = cut), bidwidth = 500)
```

```{r}
ggplot(diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..count..))
```

```{r}
ggplot(data = diamonds,
       mapping = aes(x = price, y = ..density..)) +
  geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
```

```{r}
ggplot(data = diamonds, mappping = aes(x = cut, y = price)) + 
  geom_boxplot(aes(x = cut, y = price))
```

```{r}
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot()
```

```{r}
ggplot(data = mpg) + 
  geom_boxplot(
    mapping = aes(x = reorder(class, hwy, FUN = median),
                  y = hwy)
  )
```

```{r}
ggplot(data = mpg) + 
  geom_boxplot(
    mapping = aes(x = reorder(class, hwy, FUN = median),
                  y = hwy)
  ) + 
  coord_flip()
```

```{r}
ggplot(data = diamonds) + 
  geom_count(mapping = aes(x = cut, y = color))
```

```{r}
diamonds %>% 
  count(color, cut)
```

```{r}
diamonds %>%
  count(color, cut) %>%
  ggplot(mapping = aes(x = color, y = cut)) + 
  geom_tile(mapping = aes(fill = n))
```

```{r}
ggplot(data = diamonds) + 
  geom_point(mapping = aes(x = carat, y = price))
```

```{r}
ggplot(data = diamonds) + 
  geom_point(
    mapping = aes(x = carat, y = price),
    alpha = 1/100
  )
```

```{r}
ggplot(data = smaller) + 
  geom_bin2d(mapping = aes(x = carat, y = price))
```


```{r}
ggplot(data = smaller) + 
  geom_hex(mapping = aes(x = carat, y = price))
```

```{r}
ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.01))) 
```

```{r}
ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.01)),
               varwidth = TRUE) 
```


```{r}
ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_number(carat, 20)))
```

```{r}
ggplot(data = faithful) + 
  geom_point(mapping = aes(x = eruptions, y = waiting))
```

```{r}
library(modelr)

mod <- lm(log(price) ~ log(carat), data = diamonds)

diamonds2 <- diamonds %>%
  add_residuals(mod) %>%
  mutate(resid = exp(resid))

ggplot(data = diamonds2) + 
  geom_point(mapping = aes(x = carat, y = resid))
```

```{r}
ggplot(data = diamonds2) + 
  geom_boxplot(mapping = aes(x = cut, y = resid))
```

```{r}
ggplot(data = faithful, mapping = aes(x = eruptions)) + 
  geom_freqpoly(bindwidth = 0.25)
```

```{r}
ggplot(faithful, aes(eruptions)) + 
  geom_freqpoly(binwidth = 0.25)
```

```{r}
diamonds %>%
  count(cut, clarity) %>%
  ggplot(aes(clarity, cut, fill = n)) + 
  geom_tile()
```

## 6. Workflow: Projects 

# Part 2. Wrangle 

## 7. Tibbles with tibble

```{r}
library(tidyverse)
```

```{r}
vignette('tibble')
```

```{r}
as_tibble(iris)
```

```{r}
tibble(
  x = 1:5,
  y = 1,
  z = x ^ 2 + y
)
```

```{r}
tb <- tibble(
  `:)` = 'smile',
  ` ` = 'space',
  `2000` = 'number'
)
tb
```

```{r}
tribble(
  ~x, ~y, ~z,
  'a',2,3.6,
  'b',1,8.5
)
```

```{r}
tibble(
  a = lubridate::now() + runif(1e3) * 86400,
  b = lubridate::today() + runif(1e3) * 30,
  c = 1:1e3,
  d = runif(1e3),
  e = sample(letters, 1e3, replace = TRUE)
)
```

```{r}
nycflights13::flights %>%
  print(n = 10, width = Inf)
```

```{r}
# options(tibble.print_max = n, tibble.print_min = m)
# options(tibble.width = Inf)
# nycflights13::flights %>% View()
```

```{r}
df <- tibble(
  x = runif(5),
  y = rnorm(5)
)
```

```{r}
df$x
```

```{r}
df[["x"]]
```

```{r}
df["x"]
```

```{r}
df[[1]]
```

```{r}
df[1]
```

```{r}
df %>% .$x
```

```{r}
df %>% .[['x']]
```

```{r}
df %>% .['x']
```


```{r}
# turn tibble back to basic r data frame 
class(as.data.frame(tb))
```

## 8. Data import with readr 

```{r}
library(tidyverse)
```

```{r}
# read_csv(), read_csv2(), read_tsv(), read_delim(), read_fwf(), read_log()
```

```{r}
# heights <- read_csv('data/heights.csv')
```

```{r}
read_csv(
  'a,b,c
  1,2,3
  4,5,6'
)
```

```{r}
# read_csv() use the first line of the data for the column names 
read_csv("The first line of metadata
          The second line of metadata
          x,y,z
          1,2,3
         ",
         skip = 2)
```

```{r}
read_csv("# A comment I want to skip
         x,y,z
         1,2,3",
         comment = '#')
```

```{r}
read_csv("1,2,3\n4,5,6", col_names = FALSE)
```

```{r}
read_csv('1,2,3,\n4,5,6', col_names = c('x','y','z'))
```

```{r}
read_csv('a,b,c\n1,2,.', na = '.')
```

```{r}
# compared to base R, faster, have progress bar, produce tibbles, don't convert character vectors to facors, use row names, reproducible
```

```{r}
str(parse_logical(c('TRUE','FALSE','NA')))
```

```{r}
str(parse_integer(c('1','2','3')))
```

```{r}
str(parse_date(c('2010-01-01','1979-10-14')))
```

```{r}
parse_integer(c('1','231','.','456'), na = '.')
```

```{r}
x <- parse_integer(c('123','345','abc','123.45'))
```

```{r}
x
```

```{r}
problems(x)
```

```{r}
# parse_logical(), parse_integer(), parse_double(), parse_number(), parse_character(), parse_factor(), parse_datetime(), parse_date(), parse_time()
```

```{r}
parse_double('1.23')
```

```{r}
parse_double('1,23', locale = locale(decimal_mark = ','))
```

```{r}
parse_number('$100')
parse_number('20%')
parse_number('It cost $123.45')
```

```{r}
parse_number("$123,456,789")
parse_number("123.456.789", locale = locale(grouping_mark = "."))
parse_number("123`456`789", locale = locale(grouping_mark = "`"))
```

```{r}
charToRaw('Hadley')
```

```{r}
x1 <- "El Ni\xf1o was particularly bad this year"
x2 <- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"
```

```{r}
parse_character(x1, locale = locale(encoding = "Latin1"))
parse_character(x2, locale = locale(encoding = "Shift-JIS"))
```

```{r}
guess_encoding(charToRaw(x1))
```

```{r}
guess_encoding(charToRaw(x2))
```

```{r}
fruit <- c('apple','banana')
parse_factor(c('apple','banana','bananana'), levels = fruit)
```

```{r}
parse_datetime("2010-10-01T2010")
parse_datetime("20101010")
```

```{r}
parse_date('2010-10-01')
```

```{r}
library(hms)
parse_time('01:10 am')
parse_time('20:10:01')
```

```{r}
parse_date("01/02/15","%m/%d/%y")
parse_date("01/02/15","%d/%m/%y")
parse_date("01/02/15","%y/%m/%d")
```

```{r}
parse_date("1 janvier 2015", "%d %B %Y", locale = locale("fr"))
```

```{r}
guess_parser("2010-10-01")
guess_parser("15:01")
guess_parser(c("TRUE", "FALSE"))
guess_parser(c("1","5","9"))
guess_parser(c("12, 352, 561"))
str(parse_guess("2010-10-10"))
```

```{r}
challenge <- read_csv(readr_example('challenge.csv'))
```

```{r}
problems(challenge)
```

```{r}
challenge <- read_csv(
  readr_example('challenge.csv'),
  col_types = cols(
    x = col_integer(),
    y = col_character()
  )
)
```

```{r}
challenge <- read_csv(
  readr_example("challenge.csv"),
  col_types = cols(
    x = col_double(),
    y = col_character()
  )
)
```

```{r}
tail(challenge)
```

```{r}
challenge <- read_csv(
  readr_example('challenge.csv'),
  col_types = cols(
    x = col_double(),
    y = col_date()
  )
)
```

```{r}
tail(challenge)
```

```{r}
challenge2 <- read_csv(
  readr_example('challenge.csv'),
  guess_max = 1001
)
challenge2
```

```{r}
challenge2 <- read_csv(readr_example('challenge.csv'),
                       col_types = cols(.default = col_character()))
challenge2
```

```{r}
df <- tribble(
  ~x, ~y,
  "1", "1.21",
  "2", "2.32",
  "3", "4.56"
)
df
```

```{r}
type_convert(df)
```

```{r}
write_csv(challenge, 'challenge.csv')
```

```{r}
challenge
write_csv(challenge, "challenge-2.csv")
read_csv("challenge-2.csv")
```

```{r}
write_rds(challenge, "challenge.rds")
read_rds("challenge.rds")
```

```{r}
# install.packages('feather')
library(feather)
write_feather(challenge, "challenge.feather")
read_feather("challenge.feather")
```

```{r}
# install.packages('DBI')
# install.packages('readxl')
# install.packages('jsonlite')
```


## 9. Tidy data with tidyr 

```{r}
library(tidyverse)
table1
```

```{r}
table2
```

```{r}
table3
```

```{r}
table4a
```

```{r}
table4b
```

```{r}
table1 %>%
  mutate(rate = cases / population * 10000)
```

```{r}
table1 %>%
  count(year, wt = cases)
```

```{r}
library(ggplot2)
ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), color = 'grey50') + 
  geom_point(aes(color = country))
```

```{r}
table4a
```

```{r}
table4a %>%
  gather(`1999`,`2000`,key = 'year', value = 'cases')
```

```{r}
table4b
```

```{r}
table4b %>%
  gather(`1999`,`2000`,key = 'year', value = 'population')
```

```{r}
tidy4a <- table4a %>%
  gather(`1999`, `2000`, key = "year", value = "cases")
tidy4b <- table4b %>%
  gather(`1999`, `2000`, key = "year", value = "population")
left_join(tidy4a, tidy4b, by = c('country', 'year'))
```

```{r}
table2
```

```{r}
table2 %>%
  spread(key = type, value = count)
```

```{r}
table3
```

```{r}
table3 %>%
  separate(rate, into = c('cases','population'))
```

```{r}
table3 %>%
  separate(rate, into = c('cases','population'), sep = '/')
```

```{r}
table3 %>%
  separate(
    rate, 
    into = c('cases','population'),
    convert = TRUE
  )
```

```{r}
table3 %>%
  separate(year, into = c('century', 'year'), sep = 2)
```

```{r}
table5
```

```{r}
table5 %>%
  unite(new, century, year)
```

```{r}
table5 %>%
  unite(new, century, year, sep = '')
```

```{r}
stocks <- tibble(
  year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr = c(1, 2, 3, 4, 2, 3, 4),
  return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)
)
stocks
```

```{r}
stocks %>%
  spread(key = year, value = return)
```

```{r}
stocks %>%
  spread(key = year, value = return) %>%
  gather(`2015`:`2016`, key = year, value = return, na.rm = TRUE)
  
```

```{r}
stocks %>%
  complete(year, qtr)
```

```{r}
treatment <- tribble(
  ~ person, ~ treatment, ~ response,
  "Derrick Whitmore", 1, 7,
  NA, 2, 10,
  NA, 3, 9,
  "Katherine Burke", 1, 4
)
treatment
```

```{r}
treatment %>%
  fill(person)
```

```{r}
tidyr::who
```

```{r}
who1 <- who %>% 
  gather(new_sp_m014:newrel_f65, 
         key = 'key', 
         value = 'cases',
         na.rm = TRUE)
who1
```

```{r}
who1 %>%
  count(key)
```

```{r}
who2 <- who1 %>%
  mutate(key = stringr::str_replace(key, 'newrel','new_rel'))
who2
```

```{r}
who3 <- who2 %>%
  separate(key, c('new','type','sexage'), sep = '_')
who3
```

```{r}
who3 %>%
  count(new)
```

```{r}
who4 <- who3 %>%
  select(-new, -iso2, -iso3)
who4
```

```{r}
who5 <- who4 %>%
  separate(sexage, c('sex','age'), sep = 1)
who5
```

```{r}
who %>%
  gather(code, value, new_sp_m014:newrel_f65, na.rm = TRUE) %>%
  mutate(code = stringr::str_replace(code, 'newrel','new_rel')) %>%
  separate(code, c('new','var','sexage')) %>%
  select(-new, -iso2, -iso3) %>%
  separate(sexage, c('sex','age'), sep = 1)
```


## 10. Relational data with dplyr 

```{r}
library(tidyverse)
library(nycflights13)
```

```{r}
airlines
```

```{r}
airports
```

```{r}
planes
```

```{r}
weather
```

```{r}
planes %>%
  count(tailnum) %>%
  filter(n > 1)
```

```{r}
weather %>%
  count(year, month, day, hour, origin) %>%
  filter(n > 1)
```

```{r}
flights %>%
  count(year, month, day, flight) %>%
  filter(n > 1)
```

```{r}
flights %>% 
  count(year, month, day, tailnum) %>% 
  filter(n > 1)
```

```{r}
flights2 <- flights %>%
  select(year:day, hour, origin, dest, tailnum, carrier)
flights2
```

```{r}
flights2 %>%
  select(-origin, -dest) %>%
  left_join(airlines, by = 'carrier')
```

```{r}
flights2 %>%
  select(-origin, -dest) %>%
  mutate(name = airlines$name[match(carrier, airlines$carrier)])
```

```{r}
x <- tribble(
  ~ key, ~val_X,
  1, "x1",
  2, "x2",
  3, "x3"
)
```

```{r}
y <- tribble(
  ~ key, ~ val_y,
  1, "y1",
  2, "y2",
  4, "y3"
)
```

```{r}
x %>% 
  inner_join(y, by = 'key')
```

```{r}
x <- tribble(
  ~ key, ~val_x,
  1, "x1",
  2, "x2",
  2, "x3",
  1, "x4"
)
```

```{r}
y <- tribble(
  ~ key, ~val_y,
  1, "y1",
  2, "y2"
)
```

```{r}
left_join(x, y, by = "key")
```

```{r}
x <- tribble(
  ~key, ~val_x,
  1, "x1",
  2, "x2",
  2, "x3",
  3, "x4"
)
y <- tribble(
  ~key, ~val_y,
  1, "y1",
  2, "y2",
  2, "y3",
  3, "y4"
)
left_join(x, y, by = "key")
```

```{r}
flights2 %>%
  left_join(weather)
```

```{r}
flights2 %>%
  left_join(planes, by = 'tailnum')
```

```{r}
flights2 %>%
  left_join(airports, c('dest' = 'faa'))
```

```{r}
flights2 %>%
  left_join(airports, c('origin' = 'faa'))
```

```{r}
top_dest <- flights %>%
  count(dest, sort = TRUE) %>%
  head(10)
top_dest
```

```{r}
flights %>%
  filter(dest %in% top_dest$dest)
```

```{r}
flights %>%
  semi_join(top_dest)
```

```{r}
flights %>%
  anti_join(planes, by = 'tailnum') %>%
  count(tailnum, sort = TRUE)
```

```{r}
airports %>%
  count(alt, lon) %>%
  filter(n > 1)
```

```{r}
df1 <- tribble(
  ~x, ~y,
  1, 1,
  2, 1
)
df2 <- tribble(
  ~x, ~y,
  1, 1, 
  1, 2
)
```

```{r}
intersect(df1, df2)
```

```{r}
union(df1, df2)
```

```{r}
setdiff(df1, df2)
```

```{r}
setdiff(df2, df1)
```



## 11. Strings with stringr 

```{r}
library(tidyverse)
library(stringr)
```

```{r}
string1 <- "This is a string"
string2 <- 'To put a "quote" inside a string, use single quotes'
```

```{r}
double_quote <- "\"" 
double_quote <- '"'
single_quote <- '\'' 
single_quote <- "'"
```

```{r}
backslash <- "\\"
```

```{r}
x <- c("\"", "\\")
x
writeLines(x)
```

```{r}
newline <- "\n"
```

```{r}
x <- "\u00b5"
x
```

```{r}
c("one", "two", "three")
```

```{r}
str_length(c('a','R for data science', NA))
```

```{r}
str_c('x','y')
```

```{r}
str_c('x','y','z')
```

```{r}
str_c('x','y',sep = ', ')
```

```{r}
x <- c('abc', NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
```

```{r}
# str_c() is vectorized, and it automatically recycles shorter vectors to the same length as the longest 
str_c('prefix-', c('a','b','c'), '-suffix')
```

```{r}
name <- "Hadley"
time_of_day <- "mornig"
birthday <- FALSE

str_c("Good ", time_of_day, " ", name, 
      if(birthday)" and HAPPY BIRTHDAY", ".")
```

```{r}
str_c(c("x","y","z"), collapse = ", ")
```

```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)
str_sub(x, -3, -1)
```

```{r}
str_sub("a",1,5)
```

```{r}
str_sub(x,1,1) <- str_to_lower(str_sub(x,1,1))
x
```

```{r}
str_to_upper(c("i","ı"))
str_to_upper(c("i", "ı"), locale = "tr")
```

```{r}
x <- c("apple", "eggplant","banana")
str_sort(x, locale = "en")
str_sort(x, locale = "haw")
```

```{r}
x <- c('apple', 'banana','pear')
str_view(x, 'an')
```

```{r}
str_view(x, '.a.')
```

```{r}
dot <- "\\."
writeLines(dot)
```

```{r}
str_view(c('abc','a.c','bef'), 'a\\.c')
```


```{r}
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
```

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
```

```{r}
x <- c("apple pie","apple","apple cake")
str_view(x, "apple")
str_view(x, "^apple$")
```

```{r}
str_view(c("grey","gray"),"gr(e|a)y")
```

```{r}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "CC+")
str_view(x, "C[LX]+")
```

```{r}
str_view(x, "C{2}")
str_view(x, "C{2,}")
str_view(x, "C{2,3}")
```

```{r}
str_view(x, "C{2,3}?")
str_view(x, "C[LX]+?")
```

```{r}
str_view(fruit, '(..)\\1', match = TRUE)
```

```{r}
x <- c("apple","banana","pear")
str_detect(x, 'e')
```

```{r}
# How many common words start with t?
sum(str_detect(words, '^t'))
# What proportion of common words end wit a vowel?
mean(str_detect(words, '[aeiou]$'))
```

```{r}
no_vowels_1 <- !str_detect(words, "[aeiou]")
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")
identical(no_vowels_1, no_vowels_2)
```

```{r}
words[str_detect(words, 'x$')]
```

```{r}
str_subset(words, 'x$')
```


```{r}
df <- tibble(
  word = words,
  i = seq_along(word)
)
df %>%
  filter(str_detect(words, 'x$'))
```

```{r}
x <- c("apple", "banana", "pear")
str_count(x, 'a')
```

```{r}
# On average, how many vowels per word?
mean(str_count(words, '[aeiou]'))
```

```{r}
df %>% 
  mutate(
    vowels = str_count(word, "[aeiou]"),
    consonants = str_count(word, "[^aeiou]")
  )
```

```{r}
# Matches never overlap
str_count("abababa","aba")
str_view_all("abababa","aba")
```

```{r}
length(stringr::sentences)
head(sentences)
```

```{r}
colors <- c("red", "orange", "yellow", "green", "blue", "purple")
color_match <- str_c(colors, collapse = "|")
color_match
```

```{r}
has_color <- str_subset(sentences, color_match)
matches <- str_extract(has_color, color_match)
head(matches)
```

```{r}
# str_extract() only extracts the first match 
more <- sentences[str_count(sentences, color_match)>1]
str_view_all(more, color_match)
```

```{r}
str_extract(more, color_match)
```

```{r}
str_extract_all(more, color_match)
```

```{r}
str_extract_all(more, color_match, simplify = TRUE)
```

```{r}
x <- c("a","a b","a b c")
str_extract_all(x, "[a-z]", simplify = TRUE)
```

```{r}
noun <- "(a|the) ([^ ]+)"
has_noun <- sentences %>%
  str_subset(noun) %>% 
  head(10)
has_noun %>% 
  str_extract(noun)
```

```{r}
has_noun %>%
  str_match(noun)
```

```{r}
tibble(sentence = sentences) %>% 
  tidyr::extract(
    sentence, c("article","noun"),"(a|the) ([^ ]+)", 
    remove = FALSE
  )
```

```{r}
x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")
str_replace_all(x, '[aeiou]', '-')
```

```{r}
x <- c("1 house", "2 cars", "3 people")
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))
```

```{r}
sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% 
  head(5)
```

```{r}
sentences %>%
  head(5) %>%
  str_split(" ")
```

```{r}
# list
"a|b|c|d" %>% 
  str_split("\\|")
```


```{r}
"a|b|c|d" %>% 
  str_split("\\|") %>% 
  .[[1]]
```

```{r}
# Matrix
sentences %>%
  head(5) %>%
  str_split(" ", simplify = TRUE)
```

```{r}
fields <- c("Name: Hadley", "Country: NZ", "Age: 35")
fields %>% 
  str_split(": ", n = 2, simplify = TRUE)
```

```{r}
x <- "This is a sentence. This is another sentence."
str_view_all(x, boundary("word"))
```

```{r}
str_split(x, " ")[[1]]
```

```{r}
str_split(x, boundary("word"))[[1]]
```

```{r}
str_locate(fruit, '..')
```

```{r}
str_view(fruit, "nana")
```

```{r}
str_view(fruit, regex("nana"))
```

```{r}
bananas <- c("banana", "Banana", "BANANA")
str_view(bananas, "banana")
```

```{r}
str_view(bananas, regex("banana", ignore_case = TRUE))
```

```{r}
x <- "Line 1\nLine 2\nLine 3"
str_extract_all(x, "^Line")[[1]]
str_extract_all(x, regex("^Line", multiline = TRUE))[[1]]
```

```{r}
phone <- regex("
    \\(? # optional opening parens
    (\\d{3}) # area code
    [)- ]? # optional closing parens, dash, or space
    (\\d{3}) # another three numbers
    [ -]? # optional space or dash
    (\\d{3}) # three more numbers
    ", comments = TRUE)
str_match("514-791-8141", phone)
```

```{r}
# install.packages('microbenchmark')
microbenchmark::microbenchmark(
  fixed = str_detect(sentences, fixed("the")),
  regex = str_detect(sentences, "the"),
  times = 20
)
```

```{r}
a1 <- "\u00e1"
a2 <- "a\u0301"
c(a1, a2)
a1 == a2
```

```{r}
str_detect(a1, fixed(a2))
str_detect(a1, coll(a2))
```

```{r}
i <- c("I", "İ", "i", "ı")
i

str_subset(i, coll("i", ignore_case = TRUE))

str_subset(
i,
coll("i", ignore_case = TRUE, locale = "tr")
)
```

```{r}
stringi::stri_locale_info()
```

```{r}
x <- "This is a sentence"
str_view_all(x, boundary("word"))
str_extract_all(x, boundary("word"))
```

```{r}
apropos('replace')
```

```{r}
apropos('plot')
```


```{r}
head(dir(pattern = "\\.Rmd$"))
```

```{r}
library(stringi)
```



## 12. Factors with forcats 

```{r}
library(tidyverse)
library(forcats)
```

```{r}
x1 <- c("Dec","Apr","Jan","Mar")
x2 <- c("Dec","Apr","Jam","Mar")
sort(x1)
```

```{r}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
y1 <- factor(x1, levels = month_levels)
sort(y1)
```

```{r}
y2 <- factor(x2, levels = month_levels)
y2
```

```{r}
y2 <- parse_factor(x2, levels = month_levels)
```

```{r}
factor(x1) # Default in alphabetical order
```

```{r}
f1 <- factor(x1, levels = unique(x1))
f1
```

```{r}
f2 <- x1 %>%
  factor() %>%
  fct_inorder()
f2
```

```{r}
levels(f2)
```

```{r}
class(levels)
```

```{r}
gss_cat
```

```{r}
gss_cat %>%
  count(race)
```

```{r}
ggplot(gss_cat, aes(race)) + 
  geom_bar()
```

```{r}
ggplot(gss_cat, aes(race)) + 
  geom_bar() + 
  scale_x_discrete(drop = FALSE)
```

```{r}
relig <- gss_cat %>%
  group_by(relig) %>%
  summarize(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )
ggplot(relig, aes(tvhours, relig)) + 
  geom_point()
```

```{r}
relig
```

```{r}
ggplot(relig, aes(tvhours, fct_reorder(relig, tvhours))) + 
  geom_point()
```

```{r}
relig %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
  ggplot(aes(tvhours, relig)) + 
  geom_point()
```

```{r}
rincome <- gss_cat %>%
  group_by(rincome) %>%
  summarize(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )
ggplot(rincome, 
        aes(age, fct_reorder(rincome, age))) + 
  geom_point()
```

```{r}
ggplot(
  rincome,
  aes(age, fct_relevel(rincome, 'Not applicable'))
) + 
  geom_point()
```

```{r}
by_age <- gss_cat %>%
  filter(!is.na(age)) %>%
  group_by(age, marital) %>%
  count() %>%
  mutate(prop = n/sum(n))

ggplot(by_age, aes(age, prop, color = marital)) + 
  geom_line(na.rm = TRUE)
```

```{r}
by_age
```


```{r}
ggplot(by_age, aes(age, prop, color = fct_reorder2(marital, age, prop))) + 
  geom_line() + 
  labs(color = 'marital')
```

```{r}
gss_cat %>%
  mutate(marital = marital %>%
           fct_infreq() %>%
           fct_rev()) %>%
  ggplot(aes(marital)) + 
  geom_bar()
```


```{r}
gss_cat %>% 
  count(partyid)
```

```{r}
gss_cat %>% 
  mutate(partyid = fct_recode(partyid,
"Republican, strong" = "Strong republican",
"Republican, weak" = "Not str republican",
"Independent, near rep" = "Ind,near rep",
"Independent, near dem" = "Ind,near dem",
"Democrat, weak" = "Not str democrat",
"Democrat, strong" = "Strong democrat"
                              )) %>%
  count(partyid)
```

```{r}
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
"Republican, strong" = "Strong republican",
"Republican, weak" = "Not str republican",
"Independent, near rep" = "Ind,near rep",
"Independent, near dem" = "Ind,near dem",
"Democrat, weak" = "Not str democrat",
"Democrat, strong" = "Strong democrat",
"Other" = "No answer",
"Other" = "Don't know",
"Other" = "Other party"              
                              )) %>%
  count(partyid)
```

```{r}
gss_cat %>% 
  mutate(partyid = fct_collapse(partyid,
        other = c("No answer", "Don't know", "Other party"),
        rep = c("Strong republican", "Not str republican"),
        ind = c("Ind,near rep", "Independent", "Ind,near dem"),
        dem = c("Not str democrat", "Strong democrat"))) %>%
  count(partyid)
```

```{r}
gss_cat %>%
  mutate(relig = fct_lump(relig)) %>%
  count(relig)
```

```{r}
gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10)) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
```



## 13. Dates and times with lubridate 


```{r}
library(tidyverse)
library(lubridate)
library(nycflights13)
```

```{r}
today()
now()
```

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

```{r}
ymd(20170131)
```

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

```{r}
ymd(20170131, tz = 'UTC')
```

```{r}
flights %>%
  select(year, month, day, hour, minute) 
```

```{r}
flights %>%
  select(year, month, day, hour, minute) %>%
  mutate(departure = make_datetime(year, month, day, hour, minute))
```


```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}
flights_dt <- flights %>%
  filter(!is.na(dep_time), !is.na(arr_time)) %>%
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)) %>%
select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

```{r}
flights_dt %>%
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

```{r}
flights_dt %>%
  filter(dep_time < ymd(20130102)) %>%
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

```{r}
# When use date_times in a numetic context (like in a histogram), 1 means 1 second, so a binwidth of 86400 means one day. For dates, 1 means 1 day
```

```{r}
as_datetime(today())
as_date(now())
```

```{r}
as_datetime(60*60*10)
as_date(365*10+2)
```

```{r}
datetime <- ymd_hms('2016-07-08 12:34:56')
year(datetime)
month(datetime)
mday(datetime)
yday(datetime)
wday(datetime)
```

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

```{r}
flights_dt %>%
  mutate(wday = wday(dep_time, label = TRUE)) %>%
  ggplot(aes(x = wday, y = ..count..)) + 
  geom_bar()
```

```{r}
flights_dt %>%
  mutate(minute = minute(dep_time)) %>%
  group_by(minute) %>%
  summarize(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  ) %>%
  ggplot(aes(minute, avg_delay)) + 
  geom_line()
```

```{r}
sched_dep <- flights_dt %>%
  mutate(minute = minute(sched_dep_time)) %>%
  group_by(minute) %>%
  summarize(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )
ggplot(sched_dep, aes(minute, avg_delay)) + 
  geom_line()
```

```{r}
ggplot(sched_dep, aes(minute, n)) + 
  geom_line()
```

```{r}
flights_dt %>%
  count(week = floor_date(dep_time, 'week')) %>%
  ggplot(aes(week, n)) + 
  geom_line()
```

```{r}
(datetime <- ymd_hms("2016-07-08 12:34:56"))
```

```{r}
year(datetime) <- 2020
month(datetime) <- 01
hour(datetime) <- hour(datetime) + 1
datetime
```

```{r}
update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
```

```{r}
ymd("2015-02-01") %>%
  update(mday = 30)
ymd("2015-02-01") %>%
  update(hour = 400)
```

```{r}
flights_dt %>%
  mutate(dep_hour = update(dep_time, yday = 1)) %>%
  ggplot(aes(dep_hour)) + 
  geom_freqpoly(binwidth = 300)
```

```{r}
h_age <- today() - ymd(19791014)
h_age
```

```{r}
as.duration(h_age)
```

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

```{r}
tomorrow <- today() + ddays(1)
tomorrow
```

```{r}
last_year <- today() - dyears(1)
last_year
```


```{r}
# Durations represent an exact number of seconds
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm
one_pm + ddays(1)
```

```{r}
# Periods are time spans but don't have a fixed length in seconds 
one_pm
one_pm + days(1)
```

```{r}
seconds(15)
minutes(10)
hours(c(12,24))
days(7)
months(1:6)
weeks(3)
years(1)
```

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

```{r}
# A leap year
ymd("2016-01-01") + dyears(1)
ymd("2016-01-01") + years(1)
```

```{r}
# Daylight savings time
one_pm + ddays(1)
one_pm + days(1)
```

```{r}
flights_dt %>%
  filter(arr_time < dep_time)
```

```{r}
flights_dt <- flights_dt %>%
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight * 1),
    sched_arr_time = sched_arr_time + days(overnight * 1)
  )
```

```{r}
flights_dt %>%
  filter(overnight, arr_time < dep_time)
```

```{r}
years(1)/days(1)
```

```{r}
# Interval is a duration with a starting point 
next_year <- today() + years(1)
(today() %--% next_year) / ddays(1)
```

```{r}
(today() %--% next_year) %/% days(1)
```

```{r}
class(today() %--% next_year)
```

```{r}
Sys.timezone()
```

```{r}
length(OlsonNames())
head(OlsonNames())
```

```{r}
(x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))
(x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))
(x3 <- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))
```

```{r}
x1 - x2
x1 - x3
```

```{r}
x4 <- c(x1, x2, x3)
x4
```

```{r}
x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
x4a
x4a-x4
```

```{r}
x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
x4b
x4b-x4
```



# Part 3. Program 

## 14. Pipes with magrittr 

```{r}
library(magrittr)
library(tidyverse)
```

```{r}
foo_foo <- little_bunny()
foo_foo_1 <- hop(foo_foo, through = forest)
foo_foo_2 <- scoop(foo_foo_1, up = field_mice)
foo_foo_3 <- bop(foo_foo_2, on = head)
```

```{r}
# install.packages('pryr')
diamonds <- ggplot2::diamonds
diamonds2 <- diamonds %>%
  dplyr::mutate(price_per_carat = price / carat)

pryr::object_size(diamonds)
pryr::object_size(diamonds2)
pryr::object_size(diamonds, diamonds2)
```

```{r}
diamonds$carat[1] <- NA
pryr::object_size(diamonds)
pryr::object_size(diamonds2)
pryr::object_size(diamonds, diamonds2)
```

```{r}
foo_foo <- hop(foo_foo, through = forest)
foo_foo <- scoop(foo_foo, up = field_mice)
foo_foo <- bop(foo_foo, on = head)
```

```{r}
bop(
  scoop(
    hop(foo_foo, through = forest), 
    up = field_mice
  ),
  on = head
)
```

```{r}
foo_foo %>% 
  hop(through = forest) %>%
  scoop(up = field_mouse) %>%
  bop(on = head)
```

```{r}
my_pipe <- function(.) {
. <- hop(., through = forest)
. <- scoop(., up = field_mice)
bop(., on = head)
}
my_pipe(foo_foo)
```

```{r}
assign("x", 10)
x
"x" %>% assign(100)
x
```

```{r}
env <- environment()
"x" %>% assign(100, envir = env)
x
```

```{r}
tryCatch(stop("!"), error = function(e) "An error")
```

```{r}
stop("!") %>%
  tryCatch(error = function(e) "An error")
```

```{r}
rnorm(100) %>% 
  matrix(ncol = 2) %>%
  plot() %>%
  str()
```

```{r}
rnorm(100) %>%
  matrix(ncol = 2) %T>%
  plot() %>%
  str()
```

```{r}
mtcars %$%
  cor(disp, mpg)
```

```{r}
cor(mtcars$disp, mtcars$mpg)
```

```{r}
mtcars <- mtcars %>%
  transform(cyl = cyl * 2)
```

```{r}
mtcars %<>% transform(cyl = cyl * 2)
```


## 15. Functions 

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
 (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) /
(max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) /
(max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) /
(max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

```{r}
# First: analyze the code, how many inputs does it have 
x <- df$a
(x - min(x, na.rm = TRUE))/(max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

```{r}
rescale01 <- function(x){
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0,5,10))
```

```{r}
rescale01(c(-10,0,10))
rescale01(c(1,2,3,NA,5))
```

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

```{r}
rescale01 <- function(x){
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1])/(rng[2] - rng[1])
}
rescale01(x)
```

```{r}
# f()
# my_awesome_function()
# impute_missing()
# collapse_years()
```

```{r}
col_mins <- function(x,y){}
rowMaxes <- function(x,y){}
```

```{r}
input_select()
input_checkbox()
imput_text()

select_input()
checkbox_input()
text_input()
```

```{r}
if(condition){
  # code executed when condition is TRUE
} else{
  # code executed when condition is FALSE 
}
```

```{r}
?`if`
```

```{r}
has_name <- function(x){
  nms <- names(x)
  if(is.null(nms)){
    rep(FLASE, length(x))
  } else{
    !is.na(nms) & nms != ''
  }
}
# Standard return rule: a function returns the last value that it computed 
```

```{r}
if(c(TRUE, FALSE)){}
```

```{r}
if(NA){}
```

```{r}
# Use || (or) and && (and) to combine multiple logical expressions. These operators are “short-circuiting”: as soon as ||
# sees the first TRUE it returns TRUE without computing anything else. As soon as && sees the first FALSE it returns FALSE. 
# Never use | or & in an if statement: these are vectorized operations that apply to multiple values (that’s why they are in filter()). 
# If do have a logical vector, use any() or all() to collapse it to a single value.

# Use the nonvectorized identical(). identical() is very strict: it always returns either a
# single TRUE or a single FALSE, and doesn’t coerce types.
```

```{r}
identical(0L,0)
x <- sqrt(2)^2
x
x==2
x-2
```

```{r}
dplyr::near(0L,0)
```

```{r}
if(this){
  # do that
} else if(that){
  # do something else
} else {
  # 
}
```

```{r}
function(x,y,op){
  switch(op,
         plus = x + y,
         minus = x - y,
         times = x * y,
         divide = x / y,
         stop("Unknown op!"))
}
```

```{r}
if(y < 0 && debug){
  message('Y is negative')
}
if(y == 0){
  log(x)
} else{
  y ^ x
}
```

```{r}
y <- 10
x <- if(y < 20) "Too low" else "Too high"
```

```{r}
if(y < 20){
  x <- "Too low"
} else{
  x <- "too high"
}
```

```{r}
# Compute confidence interval around mean using normal approximation 
mean_ci <- function(x, conf = 0.95){
  se <- sd(x) /sqrt(length(x))
  alpha <- 1 - conf
  mean(x) + se * qnorm(c(alpha / 2, 1-alpha / 2))
}
x <- runif(100)
mean_ci(x)
mean_ci(x, conf = 0.99)
```

```{r}
mean(1:10, na.rm = TRUE)
```

```{r}
average <- mean(feet / 12 + inches, na.rm = TRUE)
```

```{r}
# x,y,x: vectors
# w: a vector of weights 
# df: a data frame
# i,j: numeric indices (typically rows and columns) 
# n: length, or number of rows 
# p: number of columns 
```

```{r}
wt_mean <- function(x, w){
  sum(x * w) / sum(x)
}
wt_var <- function(x, w){
  mu <- wt_mean(x, w)
  sum(w * (x - mu) ^ 2) / sum(w)
}
wt_sd <- function(x, w){
  sqrt(wt_var(x, w))
}
```

```{r}
wt_mean(1:6, 1:3)
```

```{r}
wt_mean <- function(x, w){
  if(length(x) != length(w)){
    stop("'x' and 'w' must be the same length", call. = FALSE)
  }
  sum(w * x) / sum(x)
}
wt_mean(1:6, 1:3)
```

```{r}
wt_mean <- function(x, w, na.rm = FALSE){
  if(!is.logical(na.rm)){
    stop("`na.rm` must be logical")
  }
  if(length(na.rm) != 1){
    stop("`na.rm` must be length 1")
  }
  if(length(x) != length(w)){
    stop("`x` and `w` must be the same length", call.=FALSE)
  }
  if(na.rm){
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w*x) / sum(x)
}
```

```{r}
wt_mean <- function(x, w, na.rm = FALSE){
  stopifnot(is.logical(na.rm), length(na.rm) == 1)
  stopifnot(length(x) == length(w))
  
  if(na.rm){
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(x)
}
wt_mean(1:6, 6:1, na.rm = 'foo')
```

```{r}
sum(1,2,3,4,5,6,7,8,9,10)
```

```{r}
stringr::str_c("a","b","c","d","e","f")
```

```{r}
# Arbitrary number of inputs ... 
```


```{r}
commas <- function(...) stringr::str_c(..., collapse = ', ')
commas(letters[1:10])
```

```{r}
rule <- function(..., pad = '-'){
  title <- paste0(...)
  width <- getOption('width') - nchar(title) - 5
  cat(title, ' ', stringr::str_dup(pad, width), '\n', sep = '')
}
rule('Important output')
```

```{r}
x <- c(1,2)
sum(x, na.mr = TRUE)
```

```{r}
# list(...)
```

```{r}
# Lazy evaluation: arguments in R are lazily evaluated: they are not computed until they are needed 
```

```{r}
# The value returned by the function is usually the last statement it evaluates 
# Choose to return early by using return()
# when inputs are empty 
complicated_function <- function(x, y, z){
  if(length(x) == 0 || length(y) == 0){
    return(0)
  }
  # Complicated code here 
}
```

```{r}
# if statement with one complex block and one simple block 
f <- function(){
  if(x){
    # Do
    # something
    # that
    # takes 
    # many
    # lines 
    # to
    # express
  }else{
    # return something short 
  }
}
```

```{r}
f <- funtion(){
  if(!x){
    return(something_short)
  }
  # Do 
  # something
  # that
  # takes 
  # many 
  # lines 
  # to 
  # express
}
```

```{r}
# Transformation functions: there is a clear primary object that is passed in as the first argument 
# And a modified verion is returned by the function 

# Side-effect functions: called to perform an action, like drawing a plot or saving a file 
# not transforming an object 
# They should invisibly return the first argument 
```

```{r}
show_missings <- function(df){
  n <- sum(is.na(df))
  cat("Missing values: ", n, "\n", sep = '')
  invisible(df)
}
show_missings(mtcars)
```

```{r}
x <- show_missings(mtcars)
class(x)
dim(x)
```

```{r}
library(tidyverse)
mtcars %>%
  show_missings() %>%
  mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>%
  show_missings()
```

```{r}
# Environment: lexical scoping 
# Since y is not defined inside the function, R will look in the environment where the function was defined 
f <- function(x){
  x + y
}
```

```{r}
y <- 100
f(10)
```

```{r}
y <- 1000
f(10)
```

```{r}
`+` <- function(x, y) {
if (runif(1) < 0.1) {
sum(x, y)
} else {
sum(x, y) * 1.1
}
}
table(replicate(1000, 1 + 2))
#>
#> 3 3.3
#> 100 900
rm(`+`)
```


## 16. Vectors 

```{r}
library(tidyverse)
```

```{r}
# Atomic vectors (homogeneous): logical, integer, double, character, complex, raw 
# Recursie vectors (heterogeneous): lists
typeof(letters)
typeof(1:10)
x <- list("a","b",1:10)
length(x)
```

```{r}
# Augmented vectors: 
# Factors are built on top of integer vectors 
# Dates and date-times are built on top of numeric vectors 
# Data frames and tibbles are built on top of lists 
```


```{r}
1:10 %% 3 == 0
c(TRUE, TRUE, FALSE, NA)
```

```{r}
typeof(1)
typeof(1L)
1.5L
```

```{r}
# Doubles are approximations 
x <- sqrt(2) ^ 2
x
x - 2
```

```{r}
# Integers have one special value NA
# Doubles have four, NA, NaN, Inf, -Inf
c(-1, 0, 1) / 0
```

```{r}
is.finite(0)
is.infinite(Inf)
is.na(NA)
is.nan(NaN)
```

```{r}
x <- "This is a reasonably long string"
pryr::object_size(x)

y <- rep(x,1000)
pryr::object_size(y)
```

```{r}
NA # Logical 
NA_integer_ # Integer
NA_real_ # Double
NA_character_ # Character 
```

```{r}
# Explicit coercion
as.logical()
as.integer()
as.double()
```


```{r}
# Implicit coercion 
# The sum of a logical vector is the number of tures 
# The mean of a logical vector is the proportion of trues
x <- sample(20, 100, replace = TRUE)
y <- x > 10
sum(y) # how many are greater than 10
mean(y) # what proportion are greater than 10
```

```{r}
typeof(c(TRUE, 1L))
typeof(c(1L, 1.5))
typeof(c(1.5, "a"))
# An atomic vector cannot have a mix of different types 
# because the type is a property of the complete vector, not the individual elements 
```

```{r}
# Test functions 
typeof()
is_logical()
is_integer()
is_double()
is_numeric()
is_character()
is_atomic()
is_list()
is_vector()
```

```{r}
sample(10) + 100
runif(10) > 0.5
```

```{r}
# Recycling rules 
1:10 + 1:2
```

```{r}
1:10 + 1:3
```

```{r}
tibble(x = 1:4,
       y = 1:2)
```

```{r}
tibble(x = 1:4,
       y = rep(1:2,2))
```

```{r}
tibble(x = 1:4,
       y = rep(1:2, each = 2))
```

```{r}
c(x = 1, y = 2, z = 4)
```

```{r}
set_names(1:3, c("a","b","c"))
```

```{r}
# Subsetting 
x <- c("one","two","three","four","five")
x[c(3,2,5)]
```

```{r}
x[c(1,1,5,5,2)]
```

```{r}
x[c(-1, -3, -5)]
```

```{r}
x[c(1,-1)]
```

```{r}
x[0]
```

```{r}
x <- c(10,3,NA,5,8,1,NA)
x[!is.na(x)]
x[x %% 2 == 0]
```

```{r}
x <- c(abc = 1, def = 2, xyz = 5)
x[c("xyz", "def")]
```

```{r}
x <- list(1,2,3)
x
```

```{r}
str(x)
```

```{r}
x_named <- list(a = 1, b = 2, c = 3)
str(x_named)
```

```{r}
# Unlike atomic vectors, lists can contain a mix of objects 
y <- list("a",1L,1.5,TRUE)
str(y)
```

```{r}
z <- list(list(1,2),list(3,4))
str(z)
```

```{r}
x1 <- list(c(1,2),c(3,4))
x2 <- list(list(1,2),list(3,4))
x3 <- list(1,list(2,list(3)))
```

```{r}
a <- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))
```

```{r}
str(a[1:2])
```

```{r}
str(a[4])
```

```{r}
y
```

```{r}
str(y[[1]])
```

```{r}
str(y[[4]])
```

```{r}
a$a
```

```{r}
a[["a"]]
```

```{r}
# Attributes: attributes as a named list of vectors that can be attached to any object 
x <- 1:10
attr(x, "greeting")
```

```{r}
attr(x, "greeting")<-"Hi!"
attr(x, "farewell") <- "Bye!"
attributes(x)
```

```{r}
str(x)
```

```{r}
# Names: name the elements of a vector 
# Dimensions (dim): make a vector behave like a matrix or array 
# Class: implement the S3 object-oriented system 
```

```{r}
# Generic function - for object-oriented programming in R 
# make functions behave differently for different classed of input 
# "UseMethod" call a specific method, a function, based on the class of the first argument 
# All methods are functions, not all functions are methods 
as.Date
```

```{r}
# List all the methods for a generic 
methods("as.Date")
```

```{r}
getS3method("as.Date","default")
```

```{r}
getS3method("as.Date","numeric")
```

```{r}
# The most important S3 generic is print(): it controls how the
# object is printed when you type its name at the console. 
# Other important generics are the subsetting functions [, [[, and $.
```

```{r}
# Augmented vectors: Factors, Date-times and times, Tibbles 
```

```{r}
# Factors are designed to represent categorical data that can take a fixed set of possible valuea 
# factors are built on top of integers, and have a levels attribute 
x <- factor(c("ab","cd","ab"), levels = c("ab","cd","ef"))
typeof(x)
attributes(x)
```

```{r}
# Dates and Date-times 
x <- as.Date("1971-01-01")
unclass(x)
typeof(x)
attributes(x)
```

```{r}
x <- lubridate::ymd_hm("1970-01-01 01:00")
unclass(x)
typeof(x)
attributes(x)
```

```{r}
attr(x, "tzone") <- "US/Pacific"
x
attr(x, "tzone") <- "US/Eastern"
x
```

```{r}
y <- as.POSIXct(x)
typeof(y)
attributes(y)
```

```{r}
tb <- tibble::tibble(x = 1:5, y = 5:1)
typeof(tb)
attributes(tb)
```

```{r}
df <- data.frame(x = 1:5, y = 5:1)
typeof(df)
attributes(df)
```



## 17. Iteration with purrr

```{r}
library(tidyverse)
```

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
df
```

```{r}
median(df$a)
median(df$b)
median(df$c)
median(df$d)
```

```{r}
output <- vector("double", ncol(df)) # 1. output 
for (i in seq_along(df)){            # 2. sequence 
  output[[i]] <- median(df[[i]])     # 3. body 
}
output
```

```{r}
# For loop:
# 1. Output: allocate sufficient space for the output, vector(), the type of vector and the length of the vector 
# 2. Sequence: determines what to loop over 
# 3. Body: the code that does the work. Runs repeatdly, each time with a different value for i 
```

```{r}
# Modifying an existing object 
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

rescale01 <- function(x){
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
df
```

```{r}
for (i in seq_along(df)){
  df[[i]] <- rescale01(df[[i]])
}
df
```

```{r}
results <- vector('list',length(x))
names(results) <- names(x)

for (i in seq_along(x)){
  name <- names(x)[[i]]
  value <- x[[i]]
}
```

```{r}
# Unknown output length 
means <- c(0,1,2)

output <- double()
for(i in seq_along(means)){
  n <- sample(100,1)
  output <- c(output, rnorm(n, means[[i]]))
}
str(output)
```

```{r}
out <- vector('list',length(means))

for(i in seq_along(means)){
  n <- sample(100,1)
  out[[i]] <- rnorm(n, means[[i]])
}

str(out)
str(unlist(out))
```

```{r}
# Unknown sequence length 
while(condition){
  # body 
}
```

```{r}
for(i in seq_along(x)){
  # body 
}

# Equivalent to 
i <- 1
while(i <= length(x)){
  # body
  i <- i + 1 
}
```

```{r}
flip <- function() sample(c('T','H'),1)

flips <- 0
nheads <- 0

while(nheads < 3){
  if(flip() == 'H'){
    nheads <- nheads + 1
  } else{
    nheads <- 0
  }
  flips <- flips + 1
}
flips
```

```{r}
# For loops versus functionals: 
# loops are not as important in R as they are in other languages
# Because R is a functional programming language
# It is possible to wrap up for loops in a function
# And call that function instead of using the for loop directly 

df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
df
```

```{r}
# Compute the mean of every column 
output <- vector('double', length(df))
for (i in seq_along(df)){
  output[[i]] <- mean(df[[i]])
}
output
```

```{r}
col_mean <- function(df){
  output <- vector('double', length(df))
  for (i in seq_along(df)){
    output[[i]] <- mean(df[[i]])
  }
  output
}
col_mean(df)
```

```{r}
col_median <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- median(df[[i]])
  }
  output
}
col_median(df)
```

```{r}
col_sd <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- sd(df[[i]])
  }
  output
}
col_sd(df)
```

```{r}
f1 <- function(x) abs(x - mean(x)) ^ 1
f2 <- function(x) abs(x - mean(x)) ^ 2
f3 <- function(x) abs(x - mean(x)) ^ 3
```

```{r}
f <- function(x, i) abs(x - mean(x)) ^ i
```

```{r}
# Passing a function to another function 
col_summary <- function(df, fun){
  out <- vector('double', length(df))
  for(i in seq_along(df)){
    out[[i]] <- fun(df[[i]])
  }
  out
}
col_summary(df, median)
col_summary(df, mean)
```

```{r}
# The map functions: 
# Each function takes a vector as input, applies a function to each piece
# And then returns a new vector that's the same length and has the same names as the input 
map()
map_lgl()
map_int()
map_dbl()
map_chr()
```

```{r}
map_dbl(df, mean)
map_dbl(df, median)
map_dbl(df, sd)
# Compated to using a for loop, focus is on the operation being performed 
# (ie, mean(), median(), sd()), not the bookkeeping required to loop over 
# every element and store the output 
```

```{r}
df %>% map_dbl(mean)
df %>% map_dbl(median)
df %>% map_dbl(sd)
```

```{r}
df %>% summarize(mean(a))
```

```{r}
map_dbl(df, mean, trim = 0.5, na.rm = TRUE)
```

```{r}
z <- list(x = 1:3, y = 4:5)
map_int(z, length)
```

```{r}
# splits up the mtcars dataset into three pieces (one for each value of cylinder) and 
# fits the same linear model to each piece:
models <- mtcars %>%
  split(.$cyl) %>%
  map(function(df) lm(mpg ~ wt, data = df))
models
```

```{r}
lm(mpg ~ cyl + wt, data = mtcars)
```

```{r}
mtcars %>% split(.$cyl) %>% .$`4`
```

```{r}
models <- mtcars %>%
  split(.$cyl) %>%
  map(~lm(mpg ~ wt, data = .))
models
# . as a pronoun, it refers to the current list element
# in the same way that i referred to the current index in the for loop 
```

```{r}
models
```

```{r}
models %>%
  map(summary) %>%
  map_dbl(~.$r.squared)
```


```{r}
models %>%
  map(summary) %>%
  map_dbl("r.squared")
```

```{r}
x <- list(list(1,2,3), list(4,5,6), list(7,8,9))
x
```

```{r}
x %>% map_dbl(2)
```

```{r}
# Base R 
# lapply(), sapply(), vapply()
x1 <- list(
c(0.27, 0.37, 0.57, 0.91, 0.20),
c(0.90, 0.94, 0.66, 0.63, 0.06),
c(0.21, 0.18, 0.69, 0.38, 0.77)
)
x2 <- list(
c(0.50, 0.72, 0.99, 0.38, 0.78),
c(0.93, 0.21, 0.65, 0.13, 0.27),
c(0.39, 0.01, 0.38, 0.87, 0.34)
)
```

```{r}
threshold <- function(x, cutoff = 0.8) x[x > cutoff]
x1 %>% sapply(threshold) %>% str()
```

```{r}
x2 %>% sapply(threshold) %>% str()
```

```{r}
# Dealing with failure 
safe_log <- safely(log)
str(safe_log(10))
str(safe_log("a"))
```

```{r}
# safely() is designed to work with map()
x <- list(1, 10, 'a')
y <- x %>% map(safely(log))
str(y)
```

```{r}
y <- y %>% transpose()
str(y)
```

```{r}
is_ok <- y$error %>% map_lgl(is_null)
x[!is_ok]
y$result[is_ok] %>% flatten_dbl
```

```{r}
x <- list(1, 10, 'a')
x %>% map_dbl(possibly(log, NA_real_))
```

```{r}
x <- list(1, -1)
x %>% map(quietly(log)) %>% str()
```

```{r}
# Mapping over multiuple arguments 
mu <- list(5, 10, -3)
mu %>%
  map(rnorm, n = 5) %>%
  str()
```

```{r}
sigma <- list(1, 5, 10)
seq_along(mu) %>%
  map(~rnorm(5, mu[[.]], sigma[[.]])) %>%
  str()
```

```{r}
# map2() iterates over two vectors in parallel 
map2(mu, sigma, rnorm, n = 5) %>% str()
```

```{r}
map2 <- function(x,y,f,...){
  out <- vector("list",length(x))
  for(i in seq_along(x)){
    out[[i]]<-f(x[[i]],y[[i]],...)
  }
  out
}
```

```{r}
n <- list(1, 3, 5)
args1 <- list(n, mu, sigma)
args1 %>%
  pmap(rnorm) %>%
  str()
```

```{r}
args2 <- list(mean = mu, sd = sigma, n = n)
args2 %>%
  pmap(rnorm) %>%
  str()
```

```{r}
params <- tribble(
  ~mean, ~sd, ~n,
  5,1,1,
  10, 5, 3,
  -3, 10, 5
)
params %>%
  pmap(rnorm)
```

```{r}
args(rnorm)
```

```{r}
# Invoking different functions
# Varying the arguments to the function, also vary the function itself 

f <- c("runif","rnorm","rpois")
param <- list(
  list(min = -1, max = 1),
  list(sd = 5),
  list(lambda = 10)
)
```

```{r}
invoke_map(f, param, n = 5) %>%
  str()
```

```{r}
sim <- tribble(
  ~f, ~params,
  "runif", list(min = 1, max = 1),
  "rnorm", list(sd = 5),
  "rpois", list(lambda = 10)
)
sim %>% mutate(sim = invoke_map(f,params,n=10))
```

```{r}
# Walk is an alternative to map that call a function for its side effects rather than for its return value 
# The important thing is the action not the return value 
# render output to the screen or save files to disk 
x <- list(1, 'a', 3)
x %>% walk(print)
```

```{r}
library(ggplot2)

plots <- mtcars %>%
  split(.$cyl) %>%
  map(~ggplot(., aes(mpg, wt)) + geom_point())
paths <- stringr::str_c(names(plots), ".pdf")

pwalk(list(paths, plots), ggsave, path = tempdir())
```

```{r}
str(iris)
```


```{r}
iris %>%
  keep(is.factor) %>%
  str()
```

```{r}
iris %>%
  discard(is.factor) %>%
  str()
```

```{r}
x <- list(1:5, letters, list(10))
x %>%
  some(is_character)
```

```{r}
x %>%
  every(is_vector)
```

```{r}
x <- sample(10)
x

x %>% 
  detect(~ .>5)

x %>%
  detect_index(~ .>5)
```

```{r}
x %>%
  head_while(~. >5)

x %>%
  tail_while(~. >5)
```

```{r}
# Joining all data frames together 
dfs <- list(
  age = tibble(name = "John", age = 30),
  sex = tibble(name = c("John", "Mary"), sex = c("M","F")),
  trt = tibble(name = "Mary", treatment = "A")
)
dfs
```

```{r}
dfs %>% reduce(full_join)
```

```{r}
vs <- list(
  c(1,3,5,6,10),
  c(1,2,3,7,8,10),
  c(1,2,3,4,8,9,10)
)
vs
```

```{r}
vs %>% reduce(intersect)
```

```{r}
x <- sample(10)
x
x %>% accumulate(`+`)
```



# Part 4. Model

## 18. Model basics with modelr 

```{r}
library(tidyverse)
library(modelr)
options(na.action = na.warn)
```

```{r}
ggplot(sim1, aes(x, y)) + 
  geom_point()
```

```{r}
models <- tibble(
  a1 = runif(250, -20, 40),
  a2 = runif(250,-5,5)
)
ggplot(sim1, aes(x,y)) + 
  geom_abline(
    aes(intercept = a1, slope = a2),
    data = models, alpha = 1/4
  ) + 
  geom_point()
```

```{r}
model1 <- function(a, data){
  a[1] + data$x * a[2]
}
model1(c(7,1.5), sim1)
```

```{r}
measure_distance <- function(mod, data){
  diff <- data$y - model1(mod, data)
  sqrt(mean(diff^2))
}
measure_distance(c(7,1.5),sim1)
```

```{r}
sim1_dist <- function(a1, a2){
  measure_distance(c(a1, a2), sim1)
}
models <- models %>%
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
models 
```

```{r}
ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, color = 'grey30') + 
  geom_abline(
    aes(intercept = a1, slope = a2, color = -dist),
    data = filter(models, rank(dist) <= 10)
  )
```

```{r}
ggplot(models, aes(a1, a2)) + 
  geom_point(
    data = filter(models, rank(dist) <= 10),
    size = 4, color = 'red'
  ) + 
  geom_point(aes(color = -dist))
```

```{r}
grid <- expand.grid(
  a1 = seq(-5, 20, length = 25),
  a2 = seq(1, 3, length = 25)
) %>%
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
grid
```

```{r}
grid %>%
  ggplot(aes(a1, a2)) + 
  geom_point(
    data = filter(grid, rank(dist) <= 10),
    size = 4, color = 'red'
  ) + 
  geom_point(aes(color = -dist))
```

```{r}
ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, color = 'grey30') + 
  geom_abline(
    aes(intercept = a1, slope = a2, color = -dist),
    data = filter(grid, rank(dist) <= 10)
  )
```

```{r}
best <- optim(c(0,0), measure_distance, data = sim1)
best$par
```

```{r}
ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, color = 'grey30') + 
  geom_abline(intercept = best$par[1], slope = best$par[2])
```


```{r}
sim1_mod <- lm(y ~ x, data = sim1)
coef(sim1_mod)
```

```{r}
grid <- sim1 %>%
  data_grid(x)
grid
```

```{r}
sim1
```

```{r}
grid <- grid %>%
  add_predictions(sim1_mod)
grid
```

```{r}
ggplot(sim1, aes(x)) + 
  geom_point(aes(y = y)) + 
  geom_line(
    aes(y = pred),
    data = grid,
    color = 'red',
    size = 1
  )
```

```{r}
sim1 <- sim1 %>%
  add_residuals(sim1_mod)
sim1
```

```{r}
ggplot(sim1, aes(resid)) + 
  geom_freqpoly(binwidth = 0.5)
```

```{r}
ggplot(sim1, aes(x, resid)) + 
  geom_ref_line(h = 0) + 
  geom_point()
```

```{r}
df <- tribble(
  ~y, ~x1, ~x2,
  4,2,5,
  5,1,6
)
model_matrix(df, y ~ x1)
```

```{r}
model_matrix(df, y ~ x1 - 1)
```

```{r}
model_matrix(df, y ~ x1 + x2)
```

```{r}
df <- tribble(
  ~sex, ~response,
  "male",1,
  "female",2,
  "male",1
)
model_matrix(df, response ~ sex)
```

```{r}
ggplot(sim2) + 
  geom_point(aes(x,y))
```

```{r}
mod2 <- lm(y ~ x, data = sim2)
grid <- sim2 %>%
  data_grid(x) %>%
  add_predictions(mod2)
grid
```

```{r}
ggplot(sim2, aes(x)) + 
  geom_point(aes(y = y)) + 
  geom_point(
    data = grid,
    aes(y = pred),
    color = "red",
    size = 4
  )
```

```{r}
tibble(x = "e") %>%
  add_predictions(mod2)
```

```{r}
ggplot(sim3, aes(x1,y)) + 
  geom_point(aes(color = x2))
```

```{r}
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
```

```{r}
grid <- sim3 %>%
  data_grid(x1, x2) %>%
  gather_predictions(mod1, mod2)
grid
```

```{r}
ggplot(sim3, aes(x1, y, color = x2)) + 
  geom_point() + 
  geom_line(data = grid, aes(y = pred)) + 
  facet_wrap(~model)
```

```{r}
sim3 <- sim3 %>%
  gather_residuals(mod1, mod2)

ggplot(sim3, aes(x1, resid, color = x2)) + 
  geom_point() + 
  facet_grid(model ~ x2)
```

```{r}
mod1 <- lm(y ~ x1 + x2, data = sim4)
mod2 <- lm(y ~ x1 * x2, data = sim4)

grid <- sim4 %>%
  data_grid(
    x1 = seq_range(x1,5),
    x2 = seq_range(x2,5)
  ) %>%
  gather_predictions(mod1, mod2)
grid
```

```{r}
seq_range(c(0.0123,0.923423),n=5)
seq_range(c(0.0123,0.923423),n=5,pretty=TRUE)
```

```{r}
x1 <- rcauchy(100)
seq_range(x1,n=5)
seq_range(x1,n=5,trim=0.1)
seq_range(x1,n=5,trim=0.25)
seq_range(x1,n=5,trim=0.5)
```

```{r}
x2 <- c(0,1)
seq_range(x2, n = 5)
seq_range(x2,n=5,expand=0.1)
seq_range(x2,n=5,expand=0.25)
seq_range(x2,n=5,expand=0.5)
```

```{r}
ggplot(grid, aes(x1, x2)) + 
  geom_tile(aes(fill = pred)) + 
  facet_wrap(~ model)
```

```{r}
ggplot(grid, aes(x1, pred, color = x2, group = x2)) + 
  geom_line() + 
  facet_wrap(~model)
```

```{r}
ggplot(grid, aes(x2, pred, color = x1, group = x1)) + 
  geom_line() + 
  facet_wrap(~model)
```

```{r}
df <- tribble(
  ~y, ~x,
  1,1,
  2,2,
  3,3
)
model_matrix(df, y ~ x^2 + x)
```

```{r}
model_matrix(df, y ~ I(x^2) + x)
```

```{r}
model_matrix(df, y ~ poly(x,2))
```

```{r}
library(splines)
model_matrix(df, y ~ ns(x,2))
```

```{r}
sim5 <- tibble(
  x = seq(0, 3.5 * pi, length = 50),
  y = 4 * sin(x) + rnorm(length(x))
)
ggplot(sim5, aes(x,y)) + 
  geom_point()
```

```{r}
mod1 <- lm(y ~ ns(x, 1), data = sim5)
mod2 <- lm(y ~ ns(x, 2), data = sim5)
mod3 <- lm(y ~ ns(x, 3), data = sim5)
mod4 <- lm(y ~ ns(x, 4), data = sim5)
mod5 <- lm(y ~ ns(x, 5), data = sim5)
```

```{r}
grid <- sim5 %>%
  data_grid(x = seq_range(x, n = 50, expand = 0.1)) %>%
  gather_predictions(mod1, mod2, mod3, mod4, mod5, .pred = 'y')

ggplot(sim5, aes(x, y)) + 
  geom_point() + 
  geom_line(data = grid, color = 'red') + 
  facet_wrap(~model)
```

```{r}
df <- tribble(
  ~x, ~y,
  1,2.2,
  2,NA,
  3,3.5,
  4,8.3,
  NA,10
)
mod <- lm(y ~ x, data = df)
```

```{r}
mod <- lm(y ~ x, data = df, na.action = na.exclude)
nobs(mod)
```

```{r}
# generalized linear models, stats::glm()
# generalized additive models, mgcv::gam()
# penalized linear models, glmnet::glmnet()
# robust linear models, MASS::rlm()
# trees, rpart::rpart(), randomForest, xgboost
```


## 19. Model building 

```{r}
library(tidyverse)
library(modelr)
options(na.action = na.warn)
library(nycflights13)
library(lubridate)
```

```{r}
ggplot(diamonds, aes(cut, price)) + geom_boxplot()
ggplot(diamonds, aes(color, price)) + geom_boxplot()
ggplot(diamonds, aes(clarity, price)) + geom_boxplot()
```

```{r}
ggplot(diamonds, aes(carat, price)) + 
  geom_hex(bins = 50)
```

```{r}
diamonds2 <- diamonds %>%
  filter(carat <= 2.5) %>%
  mutate(lprice = log2(price), lcarat = log2(carat))
```

```{r}
ggplot(diamonds2, aes(lcarat, lprice)) + 
  geom_hex(bins = 50)
```

```{r}
mod_diamond <- lm(lprice ~ lcarat, data = diamonds2)
```

```{r}
grid <- diamonds2 %>%
  data_grid(carat = seq_range(carat, 20)) %>%
  mutate(lcarat = log2(carat)) %>%
  add_predictions(mod_diamond, 'lprice') %>%
  mutate(price = 2 ^ lprice)

ggplot(diamonds2, aes(carat, price)) + 
  geom_hex(bins = 50) + 
  geom_line(data = grid, color = 'red', size = 1)
```

```{r}
diamonds2 <- diamonds2 %>% 
  add_residuals(mod_diamond, 'lresid')

ggplot(diamonds2, aes(lcarat, lresid)) + 
  geom_hex(bins = 50)
```

```{r}
ggplot(diamonds2, aes(cut, lresid)) + geom_boxplot()
ggplot(diamonds2, aes(color, lresid)) + geom_boxplot()
ggplot(diamonds2, aes(clarity, lresid)) + geom_boxplot()
```

```{r}
mod_diamond2 <- lm(
  lprice ~ lcarat + color + cut + clarity, 
  data = diamonds2
)
```

```{r}
grid <- diamonds2 %>%
  data_grid(cut, .model = mod_diamond2) %>%
  add_predictions(mod_diamond2)
grid
```

```{r}
ggplot(grid, aes(cut, pred)) + 
  geom_point()
```

```{r}
diamonds2 <- diamonds2 %>%
  add_residuals(mod_diamond2, 'lresid2')

ggplot(diamonds2, aes(lcarat, lresid2)) + 
  geom_hex(bins = 50)
```

```{r}
diamonds2 %>%
  filter(abs(lresid2) > 1) %>%
  add_predictions(mod_diamond2) %>%
  mutate(pred = round(2^pred)) %>%
  select(price, pred, carat:table, x:z) %>%
  arrange(price)
```

```{r}
daily <- flights %>%
  mutate(date = make_date(year, month, day)) %>%
  group_by(date) %>%
  summarize(n = n())
daily
```

```{r}
ggplot(daily, aes(date, n)) + geom_line()
```

```{r}
daily <- daily %>%
  mutate(wday = wday(date, label = TRUE))

ggplot(daily, aes(wday, n)) + 
  geom_boxplot()
```

```{r}
mod <- lm(n ~ wday, data = daily)

grid <- daily %>%
  data_grid(wday) %>%
  add_predictions(mod, 'n')

ggplot(daily, aes(wday, n)) + 
  geom_boxplot() + 
  geom_point(data = grid, color = 'red', size = 4)
```

```{r}
daily <- daily %>%
  add_residuals(mod)
daily %>%
  ggplot(aes(date, resid)) + 
  geom_ref_line(h = 0) + 
  geom_line()
```

```{r}
ggplot(daily, aes(date, resid, color = wday)) + 
  geom_ref_line(h = 0) + 
  geom_line
```

```{r}
daily %>%
  filter(resid < -100)
```

```{r}
daily %>%
  ggplot(aes(date, resid)) + 
  geom_ref_line(h = 0) + 
  geom_line(color = 'grey50') + 
  geom_smooth(se = FALSE, span = 0.20)
```

```{r}
daily %>%
  filter(wday == 'Sat') %>%
  ggplot(aes(date, n)) + 
  geom_point() + 
  geom_line() + 
  scale_x_date(
    NULL, 
    date_breaks = '1 month',
    date_labels = '%b'
  )
```

```{r}
term <- function(date){
  cut(date,
      breaks = ymd(20130101, 20130605, 20130825, 20140101),
      labels = c('spring', 'summer', 'fall'))
}

daily <- daily %>%
  mutate(term = term(date))

daily %>%
  filter(wday == 'Sat') %>%
  ggplot(aes(date, n, color = term)) + 
  geom_point(alpha = 1/3) + 
  geom_line() + 
  scale_x_date(
    NULL,
    date_breaks = '1 month',
    date_labels = '%b'
  )
```

```{r}
daily %>%
  ggplot(aes(wday, n, color = term)) + 
  geom_boxplot()
```

```{r}
mod1 <- lm(n ~ wday, data = daily)
mod2 <- lm(n ~ wday * term, data = daily)

daily %>%
  gather_residuals(without_term = mod1, with_term = mod2) %>%
  ggplot(aes(date, resid, color = model)) + 
  geom_line(alpha = 0.75)
```

```{r}
grid <- daily %>%
  data_grid(wday, term) %>%
  add_predictions(mod2, 'n')

ggplot(daily, aes(wday, n)) +
  geom_boxplot() + 
  geom_point(data = grid, color = 'red') + 
  facet_wrap( ~ term)
```

```{r}
mod3 <- MASS::rlm(n ~ wday * term, data = daily)

daily %>%
  add_residuals(mod3, 'resid') %>%
  ggplot(aes(date, resid)) + 
  geom_hline(yintercept = 0, size = 2, color = 'white') + 
  geom_line()
```

```{r}
compute_vars <- function(data){
  data %>%
    mutate(
      term = term(date),
      wday = wday(date, label = TRUE)
    )
}
```

```{r}
wday2 <- function(x) wday(x, label = TRUE)
mod3 <- lm(n ~ wday2(date) * term(date), data = daily)
```

```{r}
library(splines)

mod <- MASS::rlm(n ~ wday * ns(date, 5), data = daily)

daily %>%
  data_grid(wday, date = seq_range(date, n = 13)) %>%
  add_predictions(mod) %>%
  ggplot(aes(date, pred, color = wday)) + 
  geom_line() + 
  geom_point()
```



## 20. Many models with purrr and broom

```{r}
library(modelr)
library(tidyverse)
```

```{r}
# install.packages('gapminder')
library(gapminder)
gapminder
```

```{r}
gapminder %>%
  ggplot(aes(year, lifeExp, group = country)) + 
  geom_line(alpha = 1/3)
```

```{r}
nz <- filter(gapminder, country == 'New Zealand')
nz %>%
  ggplot(aes(year, lifeExp)) + 
  geom_line() + 
  ggtitle('Full data = ')
```

```{r}
nz_mod <- lm(lifeExp ~ year, data = nz)
nz %>%
  add_predictions(nz_mod) %>%
  ggplot(aes(year, pred)) + 
  geom_line() + 
  ggtitle('Linear trend + ')
```

```{r}
nz %>%
  add_residuals(nz_mod) %>%
  ggplot(aes(year, resid)) + 
  geom_hline(yintercept = 0, color = 'white',  size = 3) + 
  geom_line() + 
  ggtitle('Remaining pattern')
```

```{r}
# purrr::map is used to repeat an action for each variable 
# Repeat an action for each subset of rows - nested data frame 
# creates a data frame that has one row per group
# column data is a list of data frames 
# make a data frame with a column that is a list of other data frames 
by_country <- gapminder %>%
  group_by(country, continent) %>%
  nest()
by_country
```

```{r}
by_country$data[[1]]
# In a grouped data frame, each row is an observation 
# In a nested data frame, each row is a group 
```

```{r}
# List-columns 

# model-fitting function 
country_model <- function(df){
  lm(lifeExp ~ year, data = df)
}
```

```{r}
# apply it to every data frame 
models <- map(by_country$data, country_model)
```

```{r}
# store the models in the data frame 
by_country <- by_country %>%
  mutate(model = map(data, country_model))
by_country
```

```{r}
by_country %>%
  filter(continent == 'Europe')
```

```{r}
by_country %>%
  arrange(continent, country)
```

```{r}
# Unnesting 
by_country <- by_country %>%
  mutate(
    resids = map2(data, model, add_residuals)
  )
by_country
```

```{r}
by_country$resids[[1]]
```

```{r}
resids <- unnest(by_country, resids)
resids
```

```{r}
resids %>%
  ggplot(aes(year, resid)) + 
  geom_line(aes(group = country), alpha = 1/3) + 
  geom_smooth(se = FALSE)
```

```{r}
resids %>%
  ggplot(aes(year, resid, group = country)) + 
  geom_line(alpha = 1/3) + 
  facet_wrap( ~ continent)
```

```{r}
library(broom)
broom::glance(nz_mod)
```

```{r}
by_country %>%
  mutate(glance = map(model, broom::glance))
```

```{r}
by_country %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance)
```

```{r}
glance <- by_country %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance, .drop = TRUE)
glance
```

```{r}
glance %>%
  arrange(r.squared)
```

```{r}
glance %>%
  ggplot(aes(continent, r.squared)) + 
  geom_jitter(width = 0.5)
```

```{r}
bad_fit <- filter(glance, r.squared < 0.25)

gapminder %>%
  semi_join(bad_fit, by = 'country') %>%
  ggplot(aes(year, lifeExp, color = country)) + 
  geom_line()
```

```{r}
# List columns 
# A data frame is a named list of equal length vectors 
# A list is a vector 
data.frame(x = list(1:3, 3:5))
```

```{r}
data.frame(
  x = I(list(1:3, 3:5)),
  y = c("1,2","3,4,5")
)
```

```{r}
tibble(
  x = list(1:3, 3:5),
  y = c("1,2", "3,4,5")
)
```

```{r}
tribble(
  ~x, ~y,
  1:3, "1,2",
  3:5, "3,4,5"
)
```

```{r}
# list column pipeline:
# nest(), summarize() + list(), mutate() + map()
# map(), map2(), pmap()
# unnest()
```

```{r}
# Creating list-columns 
# tidyr::nest() convert a grouped data frame into a nested data frame 
# mutate() and vectorized functions that return a list 
# summarize() and summary functions that return multiple results 
# tibble::enframe() create from a named list 
```

```{r}
# nest() keeps the grouping columns as is, and bundles everything else into the list-column 
gapminder %>%
  group_by(country, continent) %>%
  nest()
```

```{r}
# nest() on ungrouped data frame, specifying which columns want to nest 
gapminder %>%
  nest(year:gdpPercap)
```

```{r}
# From vectorized functions 
# Some useful functions tale an atomic vector and return a list 
# use them inside mutate to get a list-column 
df <- tribble(
  ~x1,
  "a,b,c",
  "d,e,f,g"
)
df
```

```{r}
df %>%
  mutate(x2 = stringr::str_split(x1, ','))
```

```{r}
df %>% 
  mutate(x2 = stringr::str_split(x1, ',')) %>%
  unnest()
```

```{r}
sim <- tribble(
  ~f, ~params,
  "runif",list(min = -1, max = -1),
  "rnorm",list(sd = 5),
  "rpois",list(lambda = 10)
)
sim
```

```{r}
sim %>%
  mutate(sims = invoke_map(f, params, n = 10))
```

```{r}
sim %>%
  mutate(sims = invoke_map(f, params, n = 10)) %>%
  unnest(sims)
```

```{r}
# From multivalued summaries 
# one restriction of summarize() is that it only works with summary functions that return a single value 
mtcars %>%
  group_by(cyl) %>%
  summarize(q = quantile(mpg))
```

```{r}
# wrap the result in a list 
mtcars %>%
  group_by(cyl) %>% 
  summarize(q = list(quantile(mpg)))
```

```{r}
mtcars %>%
  group_by(cyl) %>% 
  summarize(q = list(quantile(mpg))) %>%
  unnest()
```


```{r}
probs <- c(0.01, 0.25, 0.25, 0.75, 0.99)

mtcars %>%
  group_by(cyl) %>%
  summarize(p = list(probs), q = list(quantile(mpg, probs))) %>%
  unnest()
```

```{r}
# From a named list 
x <- list(
  a = 1:5,
  b = 3:4,
  c = 5:6
)
x
```

```{r}
df <- enframe(x)
df
```

```{r}
df %>%
  mutate(
    smry = map2_chr(name, value, ~ stringr::str_c(.x, ': ', .y[1]))
  )
```

```{r}
# Simplifying list-columns 
df <- tribble(
  ~x,
  letters[1:5],
  1:3,
  runif(5)
)
df
```

```{r}
# List to vecotr 
df %>%
  mutate(
    type = map_chr(x, typeof),
    length = map_int(x, length)
  )
```

```{r}
df <- tribble(
  ~x,
  list(a = 1, b = 2),
  list(a = 2, c = 4)
)
df
```

```{r}
df %>%
  mutate(
    a = map_dbl(x, "a"),
    b = map_dbl(x, "b", .null = NA_real_)
  )
```

```{r}
# Unnesting 
# unnest() works by repeating the regular columns once for each element of the list-colomn 
tibble(x = 1:2, y = list(1:4, 1)) 
```

```{r}
tibble(x = 1:2, y = list(1:4, 1)) %>% 
  unnest(y)
```


```{r}
# cannot simultaneously unnest two columns that contain a different number of elements 
df1 <- tribble(
  ~x, ~y, ~z,
  1, c("a","b"), 1:2,
  2, "c", 3
)
df1
```

```{r}
df1 %>%
  unnest(y, z)
```

```{r}
df2 <- tribble(
  ~x, ~y, ~z,
  1, "a", 1:2,
  2, c("b","c"),3
)
df2
```

```{r}
df2 %>%
  unnest(y, z)
```

```{r}
?unnest()
```

```{r}
# broom::glance(model) model summary for each row of model 
# broom::tidy(model) coefficient in the model for wach row of model 
# broom::augment(model, data) adding extra values like residuals, and influence statistics 
```



# Part 5. Communicate 

##21. R markdown 

```{r,
eval = FALSE, # Prevents code from being evaluated 
include = FALSE, # Runs the code but doesn't show the code or results in the final document 
echo = FALSE, # Prevents code, but not the results from appearing in the finished file 
message = FALSE, # Prevents messages
warning = FALSE, # Prevent warnings 
results = 'hide', # Hide printed outputs 
fig.show = 'hide' # Hide plots 
error = TRUE # Causes the render to continue even if code returns an error 
             # The default, error = FALSE, causes knitting to fail if there is a single error in the document 
}
```
```{r}
mtcars[1:5, 1:10]
```

```{r}
knitr::kable(
  mtcars[1:5,],
  caption = "A knitr kable."
)
```

```{r, cache = TRUE, dependson = ""}
knitr::clean_cache()
```

```{r}
# Global options 

# knitr::opts_chunk$set(
#   comment = "#>",
#   collapse = TRUE)

# knitr::opts_chunk$set(
# echo = FALSE
# )
```

```{r}
# inline
# we have about `r nrow(diaamonds)` diamonds. Only `r nrow(diamonds) - nrow(smaller)` are larger than 2.5 carats. The distribution of the remainder is shown below:
```

```{r raw_data, cache.extra = file.info("a_very_large_file.csv")}
rawdata <- readr::read_csv("a_very_large_file.csv")
```

```{r}
comma <- function(x) format(x, digits = 2, big.mark = ",")
comma(3452345)
comma(.12358124331)
```

```{r}
getwd()
```

```{r}
# YAML Header 

# --- 
# output: html_document
# params: my_class:"suv"
---
  
# ```{r setup, include = FALSE}
# library(ggplot2)
# library(dplyr)
# class <- mpg %>% filter(class == params$my_class)
# ```
  
# # Fuel economy for `r params$my_class`s
# ```{r, message = FALSE}
# ggplot(class, aes(displ, hwy)) +
# geom_point() +
# geom_smooth(se = FALSE)
# ```
```

```{r}
# params:
# start: !r lubridate::ymd("2015-01-01")
# snapshot: !r lubridate::ymd_hms("2015-01-01 12:30:00")
```

```{r}
# rmarkdown::render(
#   "fuel-economy.Rmd",
#   params = list(my_class = "suv")
# )
```

```{r}
# reports <- tibble(
#  class = unique(mpg$class),
#  filename = stringr::str_c("fuel-economy-",class,".html"),
#  params = purrr:map(class, ~list(my_class = .))
#)
#reports
```

```{r}
#reports %>%
#  select(output_file = filename, params) %>%
#  purrr::pwalk(rmarkdown::render, input = "fuel-economy.Rmd")
```


## 22. Graphics for communication with ggplot2 

```{r}
library(tidyverse)
```

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class)) + 
  geom_smooth(se = TRUE) + 
  labs(
    title = paste(
      "Fuel efficiency generally decreases with engine size"
    )
  )
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(color = class)) +
geom_smooth(se = FALSE) +
labs(
title = paste(
"Fuel efficiency generally decreases with", "engine size"),
subtitle = paste(
"Two seaters (sports cars) are an exception", "because of their light weight"),
caption = "Data from fueleconomy.gov"
)
```

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class)) + 
  geom_smooth(se = FALSE) + 
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    color = "Car type"
  )
```

```{r}
df <- tibble(
x = runif(10),
y = runif(10)
)
ggplot(df, aes(x, y)) +
geom_point() +
labs(
x = quote(sum(x[i] ^ 2, i == 1, n)),
y = quote(alpha + beta + frac(delta, theta))
)
```

```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class)) + 
  geom_text(aes(label = model), data = best_in_class)
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_label(
    aes(label = model),
    data = best_in_class,
    nudge_y = 2,
    alpha = 0.5
)
```

```{r}
# install.packages('ggrepel')
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class)) + 
  geom_point(size = 3, shape = 1, data = best_in_class) + 
  ggrepel::geom_label_repel(
    aes(label = model),
    data = best_in_class
  )
```

```{r}
class_avg <- mpg %>%
group_by(class) %>%
summarize(
displ = median(displ),
hwy = median(hwy)
)

ggplot(mpg, aes(displ, hwy, color = class)) +
ggrepel::geom_label_repel(aes(label = class),
data = class_avg,
size = 6,
label.size = 0,
segment.color = NA
) +
geom_point() +
theme(legend.position = "none")
```

```{r}
label <- mpg %>%
summarize(
displ = max(displ),
hwy = max(hwy),
label = paste(
"Increasing engine size is \nrelated to decreasing fuel economy."
)
)
ggplot(mpg, aes(displ, hwy)) +
geom_point() +
geom_text(
aes(label = label),
data = label,
vjust = "top",
hjust = "right"
)
```

```{r}
label <- tibble(
displ = Inf,
hwy = Inf,
label = paste(
"Increasing engine size is \nrelated to decreasing fuel economy."
)
)
ggplot(mpg, aes(displ, hwy)) +
geom_point() +
geom_text(
aes(label = label),
data = label,
vjust = "top",
hjust = "right"
)
```

```{r}
"Increasing engine size related to decreasing fuel economy." %>%
stringr::str_wrap(width = 40) %>%
writeLines()
```

```{r}
# geom_hline(), geom_vline(), geom_rect(), geom_segment() 
```

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class))
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_color_discrete()
```

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_y_continuous(breaks = seq(15,40,by = 5))
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)
```

```{r}
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_x_date(
      NULL,
      breaks = presidential$start,
      date_labels = "'%y"
)
```

```{r}
base <- ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class))

base + theme(legend.position = "left")
base + theme(legend.position = "top")
base + theme(legend.position = "bottom")
base + theme(legend.position = "right")
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme(legend.position = "bottom") +
  guides(
    color = guide_legend(
    nrow = 1,
    override.aes = list(size = 4)
  )
)
```

```{r}
ggplot(diamonds, aes(carat, price)) + 
  geom_bin2d()

ggplot(diamonds, aes(log10(carat), log10(price))) + 
  geom_bin2d()
```

```{r}
ggplot(diamonds, aes(carat, price)) + 
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(color = drv))

ggplot(mpg, aes(displ, hwy)) +
geom_point(aes(color = drv)) +
scale_color_brewer(palette = "Set1")
```

```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_color_brewer(palette = "Set1")
```

```{r}
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, color = party)) + 
  geom_point() + 
  geom_segment(aes(xend = end, yend = id)) + 
  scale_color_manual(
    values = c(Republican = "red", Democratic = "blue")
  )
```

```{r}
df <- tibble(
x = rnorm(10000),
y = rnorm(10000)
)
ggplot(df, aes(x, y)) +
geom_hex() +
coord_fixed()
```

```{r}
# install.packages('viridis')
ggplot(df, aes(x, y)) +
geom_hex() +
viridis::scale_fill_viridis() +
coord_fixed()
```

```{r}
ggplot(mpg, mapping = aes(displ, hwy)) +
  geom_point(aes(color = class)) + 
  geom_smooth()
```

```{r}
ggplot(mpg, mapping = aes(displ, hwy)) +
  geom_point(aes(color = class)) + 
  geom_smooth() + 
  coord_cartesian(xlim = c(5,7), ylim = c(10,30))
```

```{r}
mpg %>%
  filter(displ >= 5, displ <= 7, hwy >= 10, hwy <= 30) %>%
  ggplot(aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth()
```

```{r}
suv <- mpg %>% filter(class == "suv")
compact <- mpg %>% filter(class == "compact")

ggplot(suv, aes(displ, hwy, color = drv)) + geom_point()
```

```{r}
ggplot(compact, aes(displ, hwy, color = drv)) + geom_point()
```

```{r}
x_scale <- scale_x_continuous(limits = range(mpg$displ))
y_scale <- scale_y_continuous(limits = range(mpg$hwy))
col_scale <- scale_color_discrete(limits = unique(mpg$drv))

ggplot(suv, aes(displ, hwy, color = drv)) + 
  geom_point() + 
  x_scale + 
  y_scale + 
  col_scale
```

```{r}
ggplot(compact, aes(displ, hwy, color = drv)) + 
  geom_point() + 
  x_scale + 
  y_scale + 
  col_scale
```

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class)) + 
  geom_smooth() + 
  theme_bw()
```

```{r}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(color = class)) + 
  geom_smooth() + 
  theme_dark()
```

```{r}
ggplot(mpg, aes(displ, hwy)) + geom_point()
```

```{r}
# ggsave("my_plot.pdf)
```

```{r}
# fig.width, fig.height, fig.asp, out.width, out.height
```

```{r}
# fig.width = 6, fig.asp = 0.618, fig.align = 'center', out.width = '70%', dev = 'png'
```


## 23. R markdown formats 

```{r}
# --- 
# title: "viridis Demo"
# output: html_document
# ---
```

```{r}
# rmarkdown::render(
#  "diamond-sizes.Rmd",
#  output_format = "word_document"
# )
```

```{r}
# flexdashboard

# ---
# title: "Diamonds distribution dashboard"
# output: flexdashboard::flex_dashboard
# ---
# ```{r setup, include = FALSE}
# library(ggplot2)
# library(dplyr)
# knitr::opts_chunk$set(fig.width = 5, fig.asp = 1/3)
# 
# ## Column 1
# ### Carat
# ```{r}
# ggplot(diamonds, aes(carat)) + geom_histogram(binwidth = 0.1)
# 
# ### Cut
# ```{r}
# ggplot(diamonds, aes(cut)) + geom_bar()
# 
# ### Color
# ```{r}
# ggplot(diamonds, aes(color)) + geom_bar()
# 
# ## Column 2
# ### The largest diamonds
# ```{r}
# diamonds %>%
# arrange(desc(carat)) %>%
# head(100) %>%
# select(carat, cut, color, price) %>%
# DT::datatable()
```

```{r}
# htmlwidgets
```

```{r}
# install.packages('leaflet')
library(leaflet)
leaflet() %>%
setView(174.764, -36.877, zoom = 16) %>%
addTiles() %>%
addMarkers(174.764, -36.877, popup = "Maungawhau")
```

```{r}
library(shiny)
textInput("name", "What is your name?")
numericInput("age", "How old are you?", NA, min = 0, max = 150)
```

```{r}
# bookdown, pretydoc, rticles 
```

## 24. R markdown workflow 

```{r}
# packrat, checkpoint 
```


